## 有穷自动机
### 确定性有穷自动机
#### 定义
1. 一个有穷的状态集合Q
2. 一个又穷的输入符号集合
3. 一个转移函数
4. 一个初始状态
5. 一个终结状态或接受状态的集合F F是Q的子集

#### 表达方式
可以有转移表或这转移图
- 转移表 ->表示开始  *号表示结束
- 转移图 -> start 表示开始 双圈表示结束

### 非确定性有穷自动机
转移时可以从一个状态转移到任何它能转移到的状态  
非确定性有穷自动机 它的转移函数是从一个状态转移到状态的集合
### 证明确定性和非确定性有穷自动机的等价性
#### 从NFA=> DFA
重点:子集构造  
将NFA中状态转移中的每个集合重新构造成一个新的状态即新生成一些状态的幂集的子集   
通过以上构造  就能从NFA转移成DFA
#### 从DFA=>NFA
每一个DFA都可以看成一个特别的NFA 这个NFA的转移恰恰都是只能转移成一个状态

### 带epsion转移的有穷自动机
epsion-NFA 允许自发转移  
epsion 不是字符  
#### epsion 闭包
能通过epsion 进行空转移的状态的集合
#### epsion-NFA扩展转移和语言
定义:

    基础 theta(q,epsion) = ECLOSE(q)  
    归纳 设w形同xa a不为epsion
    设theta(q,x) = {p1,p2,p3,...pk}
    设U(i=1 to k) theta(p,a) = {r1,r2,...rm}
    那么 theta(q,w) = U(j=1 to m) ECLOSE(rj)

#### 消除epsion转移
DFA的初始状态是原epsion-NFA初始状态的闭包
DFA的结束状态是包含原epsion-NFA结束状态任意一个  
设计theta(S,a)方法:

    设S={p1,p2...pk}
    计算U(i=1 to k) thete(pi,a) 这个集合是{r1,r2...,rm}
    那么新theta(s,a) = U(j=1 to m) ECLOSE(rj)

#### 证明epsion-NFA和NFA,DFA的等价性
DFA,NFA=>epsion-NFA  每个DFA,NFA都可以看成是一种特殊的epsion-NFA
epsion-NFA=>DFA,NFA 上述消除epsion转移

## 正则表达式
正则表达式能做的三种运算
1. 两个语言的并
2. 两个语言的连接
3. 某个语言的闭包(星闭包或克林闭包)   

注意  我们学的正则表达式只有以上这些运算 并不包含UNIX正则表达式中的运算

正则表达式中的两个特例  空集和epsion都属于正则语言  
任何语言的0次幂为epsion  
空集的闭包是epsion  
#### 优先级 
闭包>连接(点运算符)>并(+运算符)

#### 证明有穷自动机和正则表达式的等价性
1. DFA=> RE  
  定义表达式Rijk 表示从第i个状态到第j个状态上路径的标记中 没有大于编号为k的中间状态 中间状态不包括初始状态i个结束状态j  
  证明：  
  基础：k = 0
  包括以下三种可能  
    1. 没有这种符号 Rij0 = 空集
    2. 只有一个单符号a Rij0 = a
    3. 有多个符号 都是从i到j的 Rij0 = a1+a2...+ak  
  若从i==j 则需要注意 加上epsion
  ---
  归纳：   
  Rijk 分以下两种可能：  
    1. 未经过k 那么它属于Rijk-1的语言
    2. 经过k至少1次 那么可以标记成Rikk-1(Rkkk-1)* Rkjk-1 可以从k-1进行归纳推出  
  Rijk = Rijk-1+Rjkk-1 (Rkkk-1)* Rkjk-1  
  综上自动机生成的语言就是k从0到n的并

2. RE=>epsion-NFA
  证明：   
  这里的epsion-NFA 满足 以下三个条件
  1. 恰好只有一个接受状态
  2. 没有箭弧进入初始状态
  3. 没有箭弧进入接受状态
  ---
  基础 有三种可能  
  1. 若表达式为epsion 那么就是直接从初始状态到接受状态的epsion转移
  2. 若表达式为空集 那么就是无从初始状态到结束状态的转移
  3. 若表达式为单字符 那么就是从初始状态到结束状态的转移
  ---
  归纳 有三种操作 
  1. 并 从一个节点通过epsion转移到两个并的自动机 再通过epsion转移到接受状态
  2. 连接 两个自动机通过epsion转移进行连接
  3. 闭包 从改自动机的结束状态到初始状态有一个epsion转移

## 正则语言的性质
#### 泵引理
泵引理是用于判断某一个语言是否是正则语言的标准。  
  设L是正则语言，则存在与L相关的常数n满足： 对于任何L中的串w 如果|w| >= n 则我们可以把w打断成三个串wyz使得以下三个条件满足：  
  1. y != epsion
  2. |xy|<=n
  3. 对于所有的k>=0 串xy<sup>k</sup> 属于L
---
泵引理正确性的证明：
  若L是正则的，那么它对应某一个DFA。 假设它有n个状态，对于长度大于n的串w，我们假设它串的长度为m
  根据鸽巢原理 必有一个状态是相同的 那么就可以把w打断，那么 将中间部分重复k此仍然能被接受

#### 自动机的等价性和最小化
算法： 填表法 **需要补充**

## 上下文无关文法
#### 定义
1. 符号的有穷集合
2. 变元的又穷集合
3. 一个初始变元
4. 产生式的有穷集合
    1. 一个变元
    2. 一个产生式符号 ->
    3. 一个包含零个或多个终结符号的串　  
    存在缩写形式 用 | 连接
G=(V,T,P,R)  V 变元 T 终结符号 S 初始符号

#### 推到
  利用产生式来替换变元 =>   
  =>* 表示0步或多步推到  
  最左推到 用=>lm 最右推到 用=>rm  
#### 文法的语言(CFL)
  文法的语言是值能被上下文无关文法推到出所有终结串的集合 
  证明:  
      注意要证明正反   
      数学归纳法
#### 句型
      由初始符号推到出的串
#### 语法分析树
  定义   
  1. 内部节点是一个变元
  2. 叶节点可以是一个变元 一个终结符 或者epsilon
  3. 如果某一个内部节点标号是A,且它子节点从左到右分别是A1 A2 ... AK  
  那么 A->A1A2...AK  是一个生成式 其中某个Ai 是epsilon 则Ai是A唯一的子节点 且A->Ai 是一个生成式
---
证明推到 最左推到 最右推到 分析树 递归推理是等价的
1. 从推到到树  
  基础  一步推到  即是生成式 同时注意epsilon  
  假设存在需要n+1推理才得到w(w1w2...wk)在A中 若前n部满足 则最后一步一定是要用A的某一个生成式 不妨假设 A-> X1X2...Xk  
  分以下两种可能
  1. Xi 是终结符  那么wi = Xi
  2. Xi 是变元  那么在n+1步推理中 wi最多占了n步所以最后一步的生成式不在wi中  
    之后在构造出树 

![构造过程](http://o88xvi2w5.bkt.clouddn.com/Screenshot%20from%202016-06-05%2012-30-09.png)

2. 从树到推到
  对树的高度进行归纳
  基础  树的高度为1   那么A->w 一定是个生成式 同时也是最左推到  
  归纳 若高度是n 也就是 跟是A 从左到右分别是X1X2...Xk 这些可以是变元或者终结符
    1. 终结符 那么wi只含有Xi的串
    2. 变元  产物是终结符wi的字树  此时数的高度一定小于n 根据归纳假设  存在一个最左推到  
  最左推到的构造   
    从左到右 如果是终结符 则替换为wi  如果是变元 就进行Xi=>Wi的推到
  
  3.从推到到递归推理
  根据推理长度归纳
  基础 如推导只有一步 那么A->w是一个生成式  
  归纳 若包含n+1步 将推导写成 A=>X1X2...Xk =>w 那么我们将w打断为w1w2...wk  
  若Xi是终结符号 那么wi=Xi  
  若Xi是变元 那么有Xi=>wi 且一定小于n步

#### 文法的歧义性
存在一种语言 有多种语法分析树  
有多种推到不代表歧义 有多种最左推到或最右推到代表歧义
证明  
  - 当 从根节点语法分析树 每次变元替换都代表语法分析树最左儿子 而不同的推到会有不同的第一次不同点 这就包装了语法分析树是不同的
 - 仅当 不同的语法分析树中第一次不同用到了不同的推到 这就导致了不同的最左推到
去除歧义性 
  - 添加优先级
  - 单向结合

固有歧义性 所有文法都是歧义的

## 下推自动机
下推自动机实质是在带有epsilon转移的非确定型有穷自动机上增加一个额外功能  即能存储一串堆栈符号
1. 定义
  1. 状态的又穷集合
  2. 输入符号的又穷集合
  3. 有限的堆栈字符表
  4. 转移函数   
    自变量是三元组 (q,a,X) q代表状态 a代表输入符号或者epsilon X是堆栈符号  
    输出是二元组 (p,gama) p代表新状态 gama 代表堆栈符号串
  5. 初始状态
  6. 初始符号
  7. 接受状态(终结状态集合)
2. 图形表示
![推广转移图](http://o88xvi2w5.bkt.clouddn.com/Screenshot%20from%202016-06-05%2015-00-03.png)

3. PDA瞬时描述(ID)
使用三元组(q,w,gama)  
  1. q是状态
  2. w是剩余输入串
  3. gama 是堆栈内容  
|- 表示ID的移动  同样的也有|-*

3. PDA的语言
  1. 以终结方式接受  
  证明以终结方式接受是合理的
    - 当 模拟一遍ID的转移
    - 仅当  利用数学归纳法 根据实际情况分析

  2. 以空栈方式接受
  3. 证明 以终结方式接受与以空栈方式接受是等价的  
    空栈=>终结  增加一个初始状态P0 作用将Z0压入堆栈 之后进入状态q0 即初始状态 之后正常模拟 
    直到栈顶符号为Z0时候检测  如是转为终结状态     
    证明若原空栈则现必进入终结
      - 当 模拟
      - 仅当 说明现有条件已经将PDA限制的恨死  

    终结=>空栈 增加一个栈底符号X0  滞后进行模拟 当进入终结状态后清空堆栈  
    证明若原终结则现空栈
      - 当 模拟
      - 仅当 请空栈的条件是进入终结状态 其他情况下无法清空栈 此外 所有移动都是和原PDA相同

4. PDA和CFG的等价性 
目的是证明以下三者的等价性
  1. 上下文无关语言 CFG
  2. 被某个PDA以终结状态方式接受的语言
  3. 被某个PDA以空栈方式接受的语言
---
从文法到PDA
从PDA到文法

## 上下文无关语言的性质
#### 去除无用符号
  1. 如果对于某个终结符串w  X=>*w 我们称X是产生的
  2. 如果对摸个ab 永福S=>aXb 我么很称X是可达的  
任何一个有用的符号一定是产生的和可达的
证明以上过程后 不包含无用符号
证明两个集合相互包含
计算产生符号   
  基础: T中每个符号都是都是产生的   
  归纳: 若A->a 如果a中的符号都是产生的  那么A是产生的  包括a = epsilon  
  证明  一个方向 根据这些符号产生的顺序归纳     
        另一个方向 根据推到的长度进行归纳    
计算可达符号    
  基础: S是可达的  
  归纳: 若A可达 那么从A产生式的符号都是可达的  
  证明类似

#### 去除epsilon产生式
1. 先计算出所有可空的 做法是  如果有epsion的产生式 那么它是可空的 如果产生式中所有变元都是可空的 那他是可空的
2. 根据得到的可空的将他们组合得到去除epsion的

#### 去除单位产生式
1. 基础 自己到自己是单位生成式 
2. 若出现如(A,B) 则是单位生成式

#### 乔姆斯基范式
乔姆斯基范式只有 A->a| BC

#### 上下文无关语言的泵引理

6.2.5


## 考试
1. 多项式时间规约  证明
2. 下推自动机上下文无关文法 相互转换 等价
3. P NP  
4. 格局转换
5. CFG 
6. 泵引理
7. 对角化

