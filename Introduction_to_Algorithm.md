# 算法导论
## Charter 2 算法基础
如何用nlogn的算法复杂度解决求逆序对的数目的问题  
改造归并排序 在归并过程中 如果A[i]> A[j] 这会出现逆序对 在这样的情况下 逆序对数目加上 mid - i +1  
当排序过程完成后 得到的答案即使最后答案

## Charter 3 函数的增长
o记号 是渐进紧确的上界 相当于不带等号的O  
w记号 是渐进紧确的下界 相当于不带等号的Ω

## Charter 4 分治策略
- 买股票问题(给一张股市图 问你在什么时候买入 什么时候卖出)转化为最大子数  
      使用分治算法 将问题分成三块  全在mid左 全在mid右 从mid左到mid右   - 全在mid左  递归搜索下一层  全在mid右  同上  
      - 从mid左到mid右  θ(n) 遍历    
      - 算法复杂度 
      - T(n) = θ(1)  n=1  
      - T(n) = T(n/2) +θ(n) n>1 
---
- 矩阵乘法 Strassen算法  
      大致讲述下 假设我们求A*B 我么将A和B进行矩阵分解 每个分解成4块(n/2 n/2) 
      我再对这8块做适当的矩阵减法 就能将最后的乘法操作从8次减少成7次  
      算法复杂度就变为T(n)=7T(n/2)+θ(n^2)  

对于递归式 我们可以用代入法 递归树方法 和主方法进行解决  
  - 代入法  
      先对递归式进行假设 再更具假设进行数学归纳法证明
      在证明过程中,我们可能会发现队一个界证明失败 遇到这种情况时 我们可以减去一个低阶的项
      注意到在证明过程中 得到一个弱界不一定比一个强界容易  
      在证明过程中需要证明得到与假设一致的结论  
      在证明过程中 注意变量代换  
  
  - 递归树方法   
      递归树基本使用与产生较好的猜测,首先根据递归式得到层数,再根据递归树的层数及递归式得到每一层的代价,再计算得到总代价  
      递归树的缺点 递归树大多数时候只能得到一个较好的上界,具体还需要代入法再证明
      
  - 主方法
    对于T(n) = aT(n/b) + f(n)  
    有一下三条定理  
      1. 若对某个常数ε>0  f(n) = O(n<sup>{log<sub>b</sub>a-ε)</sup>)  T(n) = θ(n<sup>log<sub>b</sub>a</sup>)
      2. 若f(n) = O(n<sup>{log<sub>b</sub>a-ε)</sup>lgn)  T(n) = θ(n<sup>log<sub>b</sub>a</sup>lgn)
      3. 若对某个常数ε>0  f(n) = Ω(n<sup>{log<sub>b</sub>a+ε)</sup>)
         且存在某个常数c<1 和足够大的n有af(n/b)<= cf(n)  
         T(n) = θ(n<sup>log<sub>b</sub>a</sup>)  

## Charter5 概率分析和随机算法
  - 在只能调用RANDOM(0,1)的情况下如何得到RANDOM(a,b)   
    ans 将数分解成二进制 若随机得到的数不在(a,b) 范围内 则重新RANDOM
  - 存在一个BIASED-RANDOM函数 它以p的概率输出1 以1-p的概率输出0 问如何得到一个无偏的Random函数  
    ans同时计算 BiASED-RANDOM 和 1 - BIASED-RANDOM  并计算次数
  - 几种生成随机排列数组的方法  
  ```
    PERMUTE-BY-SORTING(A)  
    n = A.length  
    let P[1,n] to be a new array  
    for i=1 to n  
      P[i] = RANDOM(1,n<sup>3</sup>)  
      sortA,using P as sortkey
    
    RANDOWMIZE-IN-PLACE(A)   
    n = A.length  
    for i=1 to n
      swap(A[i],RANDOM(i,n))
  ```
## Charter6 堆排序

建堆时 算法复杂度是O(n) 不是O(nlogn)  
做法是将n/2~1的位置全部做一次MAX-HEAPIFY 这里很容易将算法时间上限看成O(nlogn) 一共(1/2*n)次 每次logn的复杂度  
但是若不光把每一次操作都看成logn的时间复杂度 而根据树的高度去计算复杂度 我们就可以得到一个准确的上界    
在建堆的时候 我们还可能用其他的做法 比如调用n次insert 那么此时 它的最坏效率就是nlogn  

---
P93 Young氏矩阵  用到了与堆排序完全相同的思想 十分经典  

堆排序可以计算逆序数  
## Charter7 快速排序
1. 对于快速排序 最重要的是了解快速排序的最坏算法复杂度是O(n<sup>2</sup>)  快速排序的优势是它的平均算法复杂度为O(nlogn) 且它的最坏算法复杂度十分难以达到
2. 快速排序最坏情况的产生是它在每次左Partition的时候每次都只分离了一个数导致退化
3. 为了解决此问题 我们将快速排序进行来随机化算法  随机取到一个数 从而使快速排序的算法复杂度变得更加的"稳定" 并且我们可以证明 甚至每次Partition的操作 分离的结果都为99:1 快速排序仍然能有很好的结果
4. 在证明期望运行时间是 用到了第五章的指示器随机变量 并通过计算两个元素比较次数算出平均算法复杂度  
  第i个元素和第j个元素需要比较只可能是他们两个之一是主元  那么这发生的概率是2/(j-i+1)  
  再将这个概率累加 即可证明平均算法复杂度是O(nlogn)

---
#### 思考题  
1. 其中有对存在多个相同元素的分析(7-2)  
  提出了一种新的算法  将元素分为3类 
    1. 与主元素相同
    2. 比主元素小 
    3. 比主元素大
  针对以上三种元素 返回两个表示范围的值 可以解决此问题
2. 面对可能会发生爆栈的问题 可以用循环解决  (7-5)
  如何保证栈的深度为O(logn)  
  每次操作 将长度小的用堆栈 长度大的用循环

3. 模糊排序 (7-6)   
  在这道题中首次提到了模糊排序  
  这里的重点在于可以将有重复的看成相等 就可以用7-2的思路解决了


## Charter8 线性时间排序
#### 利用决策树证明基于比较的排序算法下界是Ω(nlogn)  
    n!<=l<=2<sup>h</sup>  
    所以h>=nlogn 

---
#### 计数排序
在此处的计数排序有一个重要的优势,他能做到稳定的

    COUNTING-SORT(A,B,k)
    let C[0...k] be a new array
    for i = 0 to k
      C[i] = 0
    for j = 1 to A.length
      C[A[j]] = C[A[j]]+1
    for i = 1 to k
      C[i] = C[i] + C[i-1]
    for j = A.length to 1
      B[C[A[j]]] = A[j]
      C[A[j]] -=1 

在这里 通过增加一个数组B并且在最后的循环中选择倒序 使原本在后面的数字仍然是在后面 保证了稳定性

---
#### 基数排序
基数排序根据位数进行排序 从低位到高位依次进行排序   
算法复杂度: 有n个d位数 每一个数位有k个选择 O(d*(n+k))   
通过证明可以看成近似θ(n)  
基数排序是稳定的

--- 
#### 桶排序
桶排序的设计是基于数据在(0,1)上随机分布 并且能证明平均复杂度为O(n)  
桶排序的思路 先设置(0,1)上有n个桶 再依次将桶中数据装入并输出


