## 操作系统概述
#### 计算机系统的三种重要接口
1. 指令系统体系结构(ISA)  
  这是硬件和软件的分解线 应用程序可以访问应用级ISA 操作系统可以访问系统级ISA
2. 应用程序二进制接口(ABI)  
  定义了二进制间的可移植性
3. 应用程序编程接口(API)  
  通过高级语言和用户及ISA进行提供 允许应用程序访问系统硬件资源和服务

#### 操作系统的发展
1. 串行处理  
  串行处理所引发的问题
  1. 调度 用户预定时间大于实际时间导致资源的浪费
  2. 准备时间较长且一旦发生错误得重新开始
2. 简单批处理  
  设置监控程序 将一系列作业放置在批处理  
  它解决了之前串行处理的问题 
  1. 它没有空闲时间 因为一直存在等候
  2. 通过作业控制语言改善了准备时间
3. 多道批处理系统  
  它解决了当处理IO时处理器是空闲的问题  
  故在这里将多个资源分开来 当处理CPU的时候 IO可以处理下一个作业  
  在这里就存在一些计算问题  如吞吐量 平均响应时间
4. 分时系统  
  分时系统处理的是用户与计算机交互的问题 如存在多个用户 他将cpu资源分成多块 分给每一个用户

#### 虚拟机
两种实现方式 
1. 进程虚拟机 伴随进程 与进程的产生和消亡同时
2. 系统虚拟机

## 进程描述和控制
#### 进程
  在这一章 第一次提到了进程的概念  
  进程的定义有多种 如下:
  1. 一个正在执行的程序
  2. 计算机中正在运行程序的一个实例
  3. 可以分配给处理器并由处理器执行的一个实体
  4. 由单一顺序的执行线索 一个状态和一组相关的系统资源所描述的活动单位
  ---
  进程的组成
  1. 一个可执行的程序
  2. 程序所需要相关数据(变量 工作空间 缓冲区等)
  3. 程序执行的上下文 又称进程状态 包括处理器寄存器的内容 操作系统使用信息 优先级 IO完成

#### 进程模型
  - 两状态  
    运行态 未运行态 
  - 五状态  
    将非运行状态分成了两个状态 就绪和阻塞
  - 六状态  
    加入挂起态 阻塞态换出即成挂起状态  挂起状态即是在外存中 
  - 七状态   
    讲挂起态分成就绪/挂起状态 和阻塞挂起状态

#### 进程属性
1. 标识符
2. 用户可见寄存器  控制和状态寄存器 栈指针
3. 调度状态信息
4. 数据结构
5. 进程间通信
6. 进程特权
7. 存储管理
8. 资源所有权和使用情况
      
#### 进程控制块(PCB)
由操作系统创建并管理  
1. 标识符
2. 状态
3. 优先级
4. 程序计数器
5. 内存指针
6. 上下文数据
7. IO状态信息
8. 记账信息(处理器时间总和 时钟数总和等)

#### 进程控制
1. 进程创建
  1. 给新进程分配一个唯一的进程标志符
  2. 给进程分配空间
  3. 初始化进程控制块
  4. 设置正确的连接
  5. 扩充其他的数据结构

2. 进程切换
  1. 保存处理器上下文环境
  2. 更新当前处于运行状态的进程控制快
  3. 将进程控制块转移到对应队列
  4. 选择一个进程执行
  5. 更新所选进程的进程控制块，将进程转台转成运行态
  6. 更新内存管理的数据结构
  7. 恢复处理器在被选择进程的最近一次切换的上下文环境

#### 操作系统的执行
操作系统也是一种程序  他也要进程管理  
它的执行方式  
1. 无进程的内核  
    在所有进程之外执行操作系统内核  
2. 在用户进程中执行  
    内核是操作系统在用户进程中的一组例程
3. 基于进程的操作系统
    将操作系统作为一组系统进程

## 并发性:互斥和同步
临界资源是一些资源 一次只能有一个进程使用的资源  
临界区是一段代码 当另外一个进程在这段代码中运行时 这个进程就不能在这段代码中运行 使用临界资源的一段代码是临界区
信号量 有P操作和V操作 分普通信号量和二元信号量
互斥与同步: 
  - 互斥代表着多个进程同时操作一个资源
  - 同步代表着某个进程的操作对另外一个进程有影响
---
经典题：  

---
## 并发：死锁和饥饿
#### 两种资源
- 可重用资源  一次只能供一个进程使用 并且不会耗尽  如 处理器 IO通道 内外存 设备
- 可消耗资源  中断  信号 消息 IO缓冲区

#### 资源分配图
圆的代表进程 方的代表资源 进程指向资源代表请求  资源指向进程表示占有

#### 死锁的条件
1. 互斥
2. 占有且等待
3. 不可抢占
4. 循环等待   
前三个是必要条件 最后一个是充要条件

#### 死锁预防
死锁预防是通过解决死锁的必要条件来保证不会死锁  
分为以下四种：
1. 互斥  这一种不可能被静止 如果需要对资源进行访问 则必须需要支持互斥
2. 占有且等待  一次性请求所有资源  
  有两个问题 一方面是资源浪费 一方面是不一定能事先直到所需要的所有资源
3. 不可抢占  改成可抢占的 
  那么这需要在方便保存和恢复的情况下才是实用的
4. 循环等待  通过定义资源的顺序 若一个进程分配到某个资源 那么接下来只能是排在某个资源后的资源被请求   
  问题是它可能会让执行速度变慢 应为可能在没必要的情况下拒绝资源访问

#### 死锁避免
有一些矩阵需要记住：
- Resource 资源总数矩阵  
- Available  未分配的资源总量
- Claim Cij表示进程i对资源j的需求
- Allocation Aij 表示分配给进程i的资源j

死锁避免分两种，一种是进程启动时避免，即对当前所有种类的资源，已有需求加上新需求大于资源总量时 此进程就会被阻止启动。  
另外一种是资源分配拒绝，题目主要出在这一块，银行家算法在这方面是如下操作的：  
当需要一个新的资源请求时，首先判断需求是否大于剩余以及是否大于Need  
之后判断能否找到一个合适的安全序列，若可以，则允许分配

#### 死锁检测
死锁检测是最开放的一种，即每隔一段时间检测是否会发生死锁  
具体算法如下：  
1. 标记所有Allocation矩阵中一行全为0的进程
2. 标记一个临时向量W W等于Available向量
3. 检查下标i 若当前i未被标记且所有都小于等于W 
4. 若3找不到那么终止算法若找到了则标记i合并将Allocation矩阵相应行加入W

可以看出这和死锁避免十分类似  只多加了第一步为了加快运算速度

## 单处理器调度
-　长程调度　决定哪个程序可以进入系统中处理
-　中程调度　选出换入的进程
-　短程调度　决定下一次执行哪一个进程
#### 调度算法 
- FCFS
- 轮转  
  给一个时间片 轮流运行 (第二优先级是FIFO)
- SPN 短进程优先 非抢占
- SRT 最短剩余时间优先  抢占
- HRRN 高响应比优先 R = (wait_time+service_time)/service_time
- 反馈 设置多级队列 如当前队列已经未完成则进入下一个队列

## 内存管理  
#### 交换技术 (swapping)
####  覆盖技术 (overlaying)
程序员将不同的模块的内存分配到同一个区域,若不还是需要同时在内存中的模块的可以先后置入同一块内存

#### 内存管理的需要
1. 重定位 (relocation)
能保证内存在换入换出后的寻址仍能正常须知
2. 保护  
每个进程使用的内存需要受到保护,不能被随意的被其他进程访问,这需要在硬件方面上进行控制　
3. 共享  
存在保护就存在共享,共享允许过个进程访问内存的同一部分　　
4. 逻辑组织   
线性
5. 物理组织   
分为两级 内存和外存

## 内存分区
![优劣说明](http://o88xvi2w5.bkt.clouddn.com/2016-06-05%2004-08-56%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)
注意点:  不同内存分区技术解决了什么问题  
内部碎片(internal fragmentation)和外部碎片(external fragmentation)区别 以及每种分区方法解决了什么碎片
1. 固定分区 
  - 大小相等
  - 大小不等  
  大小不等部分解决了大小相等的内部碎片的问题
2. 动态分区
  - 最优适应 (best-fit)
  - 最坏适应 (worst-fit)
  - 首次适应 (fitst-fit)
  - 下次适应 (next-fit)
  每种方法的优缺点  不存在某一种算法对所有的数据都有较好的结果  只能说某种算法较好的适应了某种数据  
  压缩技术 (compaction) 
  **注意计算 (可出计算题)** 
3. 伙伴系统 **可能考**  
伙伴系统是对前两者的折中  
具体算法  
将整个分区看成2<sup>k</sup> 每次从左到右找到第一个比他所求大的但是比他所求两倍小的空间 若当前空间大于两倍 则分成两半  
合并时只有相邻且大小相同的空区间才能合并
4. 分页 (未完)
进程中称为页(page) 内存中称为页框(frame) 联系页和页框较页表(page table)  
页大小决定了几位的偏移量 剩下的决定了页号  
  - 倒排页表(inverted page table)  
      避免了多个进程导致了页表过多   
      从而使用了倒排页表 根据页号查询进程 并进行hash 并使用链保证了hash时的冲突
      
  - 多级页表   
      减少了空间(并不是所有时间都满载)
      增加了时间(多次查询内存)
  - 快表(TLB) 对应算法

5. 分段
对程序员透明 程序员可以自己决定段的大小  

6. 段页式  
先分段 在分页 采用两者的优点
### 关键术语


## 虚拟内存
之前的算法都没有解决如果一次性无法全部装入的问题 这就需要虚拟内存来解决  
常驻集(resident set) 进程执行过程中任何时候都在内存的部分  
#### 确定一个页何时进入内存有两种方式   
1. 请求分页(demand paging)  
2. 预先分页(prepaging)  
#### 置换算法 
1. 最佳 (OPT)   
  在已知后续页面的算法 用于衡量其他算法 没有实际意义
2. 最近最少使用 (LRU)  
  置换内存中上次使用距离当前最远的页
3. 先进先出 (FIFO)
4. 时钟 (CLOCK)  
  给每一个页框关联一个附加位 使用位 并设置一指针   
  当第一次装入内存或这被访问到 将其置为1   
  当中断时 从指针位置开始扫描 若为1 则将其置0 若为0 则换出 并将指针指在下一个页  
5. 改进时钟算法(ICLOCK)  
  在时钟算法访问位u的基础上 增加一个修改位 m 
  有以下四种可能 
    1. u = 0 , m = 0
    2. u = 1 , m = 0
    3. u = 0 , m = 1
    4. u = 1 , m = 1  

  算法执行过程 
  1. 找 u = 0 , m = 0  过程中不进行任何修改
  2. 找 u = 0 , m = 1  过程中将跳过的u置0
  3. 重复 1 2 步骤
6. 页缓冲
  设置一个空闲链表和一个修改链表  
  被置换出的页会放入上面两个链表 根据是否被修改  
  链表存放在内存中 
  积攒到一定程度 一次性写回
  优点: 若要访问已被置换且在链表中的数据  可以快速读取  一次性写回减少消耗

7. 驻留集管理
  - 分配策略
    - 固定分配
    - 可变分配
  - 置换策略
    - 局部置换
    - 全局置换
  不存在固定分配局部置换  
  在可变分配局部置换的情况下 出现了工作集算法(working set strategy)  
8. 清楚策略
  - 请求式清除(demand cleaning)
  - 预约式清除(precleaning)

## IO
#### 执行IO有三种技术
1. 程序控制IO  处理器代表一个进程给IO模块发送一个IO命令,让程序进入忙等待,直到操作完成才可以继续进行
2. 中断驱动IO 处理器代表IO模块发出一个IO命令  分为两种 阻塞和非阻塞  若是非阻塞 则执行后续指令 若为阻塞 则下一天是来自操作系统 将当前进程设置位阻塞并调度其他进程
3. 直接存储器访问(DMA) DMA模块控制内存和IO模块数据交换  为传送一块数据 处理器和DMA模块发请求 当整个数据块发送结束才被中断

#### 算法
1. FIFO
2. 最短服务时间优先(SSTF)
    左右来回 离当前最近
3. 电梯算法(SCAN)
    磁头从一个方向移动 在途中满足未完成请求直到最后一个磁道 再返回扫描  到第一个被需要访问到磁道
5. C-SCAN算法
    把方向限定在一个方向上 若到底部 则达到最开始的地方 再往相同方向扫描

## 文件管理
#### 文件分配
文件分配表(FAT File Allocation Table) 
分配与内存分配相似 
  - 首次分配
  - 最佳适配
  - 最近适配 (与前面分配文件块最近的组)
---

- 连续分配 一次性给一块连续的空间
- 连接分配 存一张表 分别为文件名 起始块 长度  每个文件块有一个向下一个文件块的指针
- 索引分配 存在一个表 记录每个块或者快的开始和长度


## 考试
#### 进程调度
1. 周转时间 
2. 归一化周转时间   
3. 响应时间 从进入等待队列开始  到用户得到反应  
4. 吞吐量 
5. 等待时间  
6. 处理器利用率 单位时间内cpu时间所占比例

#### PV操作
读者写者  生产者消费者
#### 银行家

#### 页面置换
1. FIFO
2. OPT  每次换已有中最晚出现的
3. LRU
4. CLOCK  最开始几个指针不变
5. 改进CLOCK
6. BuffPage 工作集 
---
1. 操作系统功能
1. 操作系统演变 
2. 操作系统成就 虚拟机 多处理器设计 概念
3. Windows overview 大题
4. 操作系统执行 概念
5. 线程基本概念  为什么要有线程  线程 进程区别
6. 互斥的硬件基础 不深
7. 死锁概念 
8. 银行家算法  和后面
9. 需求 优缺点
10. 虚存硬件软件机制 8.1 8.2
11. 9.1 9.2
12. 10.1 10.2  10.3 10.4 综合题
13. 11.1-11.8
14. 12.1 12.2 12.4 12.5  栈 堆


