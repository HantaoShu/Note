<h3>操作系统概述</h2>

<h4>计算机系统的三种重要接口</h4>

<ol>
<li>指令系统体系结构(ISA) <br />
这是硬件和软件的分解线 应用程序可以访问应用级ISA 操作系统可以访问系统级ISA</li>
<li>应用程序二进制接口(ABI) <br />
定义了二进制间的可移植性</li>
<li>应用程序编程接口(API) <br />
通过高级语言和用户及ISA进行提供 允许应用程序访问系统硬件资源和服务</li>
</ol>

<h4>操作系统的发展</h4>

<ol>
<li>串行处理 <br />
串行处理所引发的问题
<ol>
<li>调度 用户预定时间大于实际时间导致资源的浪费</li>
<li>准备时间较长且一旦发生错误得重新开始</li>
</ol></li>
<li>简单批处理 <br />
设置监控程序 将一系列作业放置在批处理 <br />
它解决了之前串行处理的问题 
<ol>
<li>它没有空闲时间 因为一直存在等候</li>
<li>通过作业控制语言改善了准备时间</li>
</ol></li>
<li>多道批处理系统 <br />
它解决了当处理IO时处理器是空闲的问题 <br />
故在这里将多个资源分开来 当处理CPU的时候 IO可以处理下一个作业 <br />
在这里就存在一些计算问题  如吞吐量 平均响应时间</li>
<li>分时系统 <br />
分时系统处理的是用户与计算机交互的问题 如存在多个用户 他将cpu资源分成多块 分给每一个用户</li>
</ol>

<h4>虚拟机</h4>

<p>两种实现方式 
1. 进程虚拟机 伴随进程 与进程的产生和消亡同时
2. 系统虚拟机</p>

<h2>进程描述和控制</h2>

<h4>进程</h4>

<p>在这一章 第一次提到了进程的概念 <br />
  进程的定义有多种 如下:
  1. 一个正在执行的程序
  2. 计算机中正在运行程序的一个实例
  3. 可以分配给处理器并由处理器执行的一个实体
  4. 由单一顺序的执行线索 一个状态和一组相关的系统资源所描述的活动单位</p>

<hr />

<p>进程的组成
  1. 一个可执行的程序
  2. 程序所需要相关数据(变量 工作空间 缓冲区等)
  3. 程序执行的上下文 又称进程状态 包括处理器寄存器的内容 操作系统使用信息 优先级 IO完成</p>

<h4>进程模型</h4>

<ul>
<li>两状态 <br />
运行态 未运行态 </li>
<li>五状态 <br />
将非运行状态分成了两个状态 就绪和阻塞</li>
<li>六状态 <br />
加入挂起态 阻塞态换出即成挂起状态  挂起状态即是在外存中 </li>
<li>七状态 <br />
讲挂起态分成就绪/挂起状态 和阻塞挂起状态</li>
</ul>

<h4>进程属性</h4>

<ol>
<li>标识符</li>
<li>用户可见寄存器  控制和状态寄存器 栈指针</li>
<li>调度状态信息</li>
<li>数据结构</li>
<li>进程间通信</li>
<li>进程特权</li>
<li>存储管理</li>
<li>资源所有权和使用情况</li>
</ol>

<h4>进程控制块(PCB)</h4>

<p>由操作系统创建并管理 <br />
1. 标识符
2. 状态
3. 优先级
4. 程序计数器
5. 内存指针
6. 上下文数据
7. IO状态信息
8. 记账信息(处理器时间总和 时钟数总和等)</p>

<h4>进程控制</h4>

<ol>
<li><p>进程创建</p>

<ol>
<li>给新进程分配一个唯一的进程标志符</li>
<li>给进程分配空间</li>
<li>初始化进程控制块</li>
<li>设置正确的连接</li>
<li>扩充其他的数据结构</li>
</ol></li>
<li><p>进程切换</p>

<ol>
<li>保存处理器上下文环境</li>
<li>更新当前处于运行状态的进程控制快</li>
<li>将进程控制块转移到对应队列</li>
<li>选择一个进程执行</li>
<li>更新所选进程的进程控制块，将进程转台转成运行态</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器在被选择进程的最近一次切换的上下文环境</li>
</ol></li>
</ol>

<h4>操作系统的执行</h4>

<p>操作系统也是一种程序  他也要进程管理 <br />
它的执行方式 <br />
1. 无进程的内核 <br />
    在所有进程之外执行操作系统内核 <br />
2. 在用户进程中执行 <br />
    内核是操作系统在用户进程中的一组例程
3. 基于进程的操作系统
    将操作系统作为一组系统进程</p>

<h2>并发性:互斥和同步</h2>

<p>临界资源是一些资源 一次只能有一个进程使用的资源 <br />
临界区是一段代码 当另外一个进程在这段代码中运行时 这个进程就不能在这段代码中运行 使用临界资源的一段代码是临界区
信号量 有P操作和V操作 分普通信号量和二元信号量
互斥与同步: 
  - 互斥代表着多个进程同时操作一个资源</p>

<h2>  - 同步代表着某个进程的操作对另外一个进程有影响</h2>

<p>经典题：  </p>

<hr />

<h2>并发：死锁和饥饿</h2>

<h4>两种资源</h4>

<ul>
<li>可重用资源  一次只能供一个进程使用 并且不会耗尽  如 处理器 IO通道 内外存 设备</li>
<li>可消耗资源  中断  信号 消息 IO缓冲区</li>
</ul>

<h4>资源分配图</h4>

<p>圆的代表进程 方的代表资源 进程指向资源代表请求  资源指向进程表示占有</p>

<h4>死锁的条件</h4>

<ol>
<li>互斥</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待 <br />
前三个是必要条件 最后一个是充要条件</li>
</ol>

<h4>死锁预防</h4>

<p>死锁预防是通过解决死锁的必要条件来保证不会死锁 <br />
分为以下四种：
1. 互斥  这一种不可能被静止 如果需要对资源进行访问 则必须需要支持互斥
2. 占有且等待  一次性请求所有资源 <br />
  有两个问题 一方面是资源浪费 一方面是不一定能事先直到所需要的所有资源
3. 不可抢占  改成可抢占的 
  那么这需要在方便保存和恢复的情况下才是实用的
4. 循环等待  通过定义资源的顺序 若一个进程分配到某个资源 那么接下来只能是排在某个资源后的资源被请求 <br />
  问题是它可能会让执行速度变慢 应为可能在没必要的情况下拒绝资源访问</p>

<h4>死锁避免</h4>

<p>有一些矩阵需要记住：
- Resource 资源总数矩阵 <br />
- Available  未分配的资源总量
- Claim Cij表示进程i对资源j的需求
- Allocation Aij 表示分配给进程i的资源j</p>

<p>死锁避免分两种，一种是进程启动时避免，即对当前所有种类的资源，已有需求加上新需求大于资源总量时 此进程就会被阻止启动。 <br />
另外一种是资源分配拒绝，题目主要出在这一块，银行家算法在这方面是如下操作的： <br />
当需要一个新的资源请求时，首先判断需求是否大于剩余以及是否大于Need <br />
之后判断能否找到一个合适的安全序列，若可以，则允许分配</p>

<h4>死锁检测</h4>

<p>死锁检测是最开放的一种，即每隔一段时间检测是否会发生死锁 <br />
具体算法如下： <br />
1. 标记所有Allocation矩阵中一行全为0的进程
2. 标记一个临时向量W W等于Available向量
3. 检查下标i 若当前i未被标记且所有都小于等于W 
4. 若3找不到那么终止算法若找到了则标记i合并将Allocation矩阵相应行加入W</p>

<p>可以看出这和死锁避免十分类似  只多加了第一步为了加快运算速度</p>

<h2>单处理器调度</h2>

<p>-　长程调度　决定哪个程序可以进入系统中处理
-　中程调度　选出换入的进程
-　短程调度　决定下一次执行哪一个进程</p>

<h4>调度算法</h4>

<ul>
<li>FCFS</li>
<li>轮转 <br />
给一个时间片 轮流运行 (第二优先级是FIFO)</li>
<li>SPN 短进程优先 非抢占</li>
<li>SRT 最短剩余时间优先  抢占</li>
<li>HRRN 高响应比优先 R = (wait<em>time+service</em>time)/service_time</li>
<li>反馈 设置多级队列 如当前队列已经未完成则进入下一个队列</li>
</ul>

<h2>内存管理</h2>

<h4>交换技术 (swapping)</h4>

<h4>覆盖技术 (overlaying)</h4>

<p>程序员将不同的模块的内存分配到同一个区域,若不还是需要同时在内存中的模块的可以先后置入同一块内存</p>

<h4>内存管理的需要</h4>

<ol>
<li>重定位 (relocation)
能保证内存在换入换出后的寻址仍能正常须知</li>
<li>保护 <br />
每个进程使用的内存需要受到保护,不能被随意的被其他进程访问,这需要在硬件方面上进行控制　</li>
<li>共享 <br />
存在保护就存在共享,共享允许过个进程访问内存的同一部分　　</li>
<li>逻辑组织 <br />
线性</li>
<li>物理组织 <br />
分为两级 内存和外存</li>
</ol>

<h2>内存分区</h2>

<p><img src="http://o88xvi2w5.bkt.clouddn.com/2016-06-05%2004-08-56%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="优劣说明" />
注意点:  不同内存分区技术解决了什么问题 <br />
内部碎片(internal fragmentation)和外部碎片(external fragmentation)区别 以及每种分区方法解决了什么碎片
1. 固定分区 
  - 大小相等
  - 大小不等 <br />
  大小不等部分解决了大小相等的内部碎片的问题
2. 动态分区
  - 最优适应 (best-fit)
  - 最坏适应 (worst-fit)
  - 首次适应 (fitst-fit)
  - 下次适应 (next-fit)
  每种方法的优缺点  不存在某一种算法对所有的数据都有较好的结果  只能说某种算法较好的适应了某种数据 <br />
  压缩技术 (compaction) 
  <strong>注意计算 (可出计算题)</strong> 
3. 伙伴系统 <strong>可能考</strong> <br />
伙伴系统是对前两者的折中 <br />
具体算法 <br />
将整个分区看成2<sup>k</sup> 每次从左到右找到第一个比他所求大的但是比他所求两倍小的空间 若当前空间大于两倍 则分成两半 <br />
合并时只有相邻且大小相同的空区间才能合并
4. 分页 (未完)
进程中称为页(page) 内存中称为页框(frame) 联系页和页框较页表(page table) <br />
页大小决定了几位的偏移量 剩下的决定了页号 <br />
  - 倒排页表(inverted page table) <br />
      避免了多个进程导致了页表过多 <br />
      从而使用了倒排页表 根据页号查询进程 并进行hash 并使用链保证了hash时的冲突</p>

<ul>
<li>多级页表 <br />
  减少了空间(并不是所有时间都满载)
  增加了时间(多次查询内存)</li>
<li>快表(TLB) 对应算法</li>
</ul>

<ol>
<li><p>分段
对程序员透明 程序员可以自己决定段的大小  </p></li>
<li><p>段页式 <br />
先分段 在分页 采用两者的优点</p>

<h3>关键术语</h3></li>
</ol>

<h2>虚拟内存</h2>

<p>之前的算法都没有解决如果一次性无法全部装入的问题 这就需要虚拟内存来解决 <br />
常驻集(resident set) 进程执行过程中任何时候都在内存的部分  </p>

<h4>确定一个页何时进入内存有两种方式</h4>

<ol>
G<li>请求分页(demand paging)  </li>
<li><p>预先分页(prepaging)  </p>

<h4>置换算法</h4></li>
<li><p>最佳 (OPT) <br />
在已知后续页面的算法 用于衡量其他算法 没有实际意义</p></li>
<li>最近最少使用 (LRU) <br />
置换内存中上次使用距离当前最远的页</li>
<li>先进先出 (FIFO)</li>
<li>时钟 (CLOCK) <br />
给每一个页框关联一个附加位 使用位 并设置一指针 <br />
当第一次装入内存或这被访问到 将其置为1 <br />
当中断时 从指针位置开始扫描 若为1 则将其置0 若为0 则换出 并将指针指在下一个页  </li>
<li><p>改进时钟算法(ICLOCK) <br />
在时钟算法访问位u的基础上 增加一个修改位 m 
有以下四种可能 </p>

<ol>
<li>u = 0 , m = 0</li>
<li>u = 1 , m = 0</li>
<li>u = 0 , m = 1</li>
<li>u = 1 , m = 1  </li>
</ol>

<p>算法执行过程 </p>

<ol>
<li>找 u = 0 , m = 0  过程中不进行任何修改</li>
<li>找 u = 0 , m = 1  过程中将跳过的u置0</li>
<li>重复 1 2 步骤</li>
</ol></li>
<li><p>页缓冲
设置一个空闲链表和一个修改链表 <br />
被置换出的页会放入上面两个链表 根据是否被修改 <br />
链表存放在内存中 
积攒到一定程度 一次性写回
优点: 若要访问已被置换且在链表中的数据  可以快速读取  一次性写回减少消耗</p></li>
<li><p>驻留集管理</p>

<ul>
<li>分配策略</li>
<li>固定分配</li>
<li>可变分配</li>
<li>置换策略</li>
<li>局部置换</li>
<li>全局置换
不存在固定分配局部置换 <br />
在可变分配局部置换的情况下 出现了工作集算法(working set strategy)  </li>
</ul></li>
<li>清楚策略
<ul>
<li>请求式清除(demand cleaning)</li>
<li>预约式清除(precleaning)</li>
</ul></li>
</ol>

<h2>IO</h2>

<h4>执行IO有三种技术</h4>

<ol>
<li>程序控制IO  处理器代表一个进程给IO模块发送一个IO命令,让程序进入忙等待,直到操作完成才可以继续进行</li>
<li>中断驱动IO 处理器代表IO模块发出一个IO命令  分为两种 阻塞和非阻塞  若是非阻塞 则执行后续指令 若为阻塞 则下一天是来自操作系统 将当前进程设置位阻塞并调度其他进程</li>
<li>直接存储器访问(DMA) DMA模块控制内存和IO模块数据交换  为传送一块数据 处理器和DMA模块发请求 当整个数据块发送结束才被中断</li>
</ol>

<h4>算法</h4>

<ol>
<li>FIFO</li>
<li>最短服务时间优先(SSTF)
左右来回 离当前最近</li>
<li>电梯算法(SCAN)
磁头从一个方向移动 在途中满足未完成请求直到最后一个磁道 再返回扫描  到第一个被需要访问到磁道</li>
<li>C-SCAN算法
把方向限定在一个方向上 若到底部 则达到最开始的地方 再往相同方向扫描</li>
</ol>

<h2>文件管理</h2>

<h4>文件分配</h4>

<p>文件分配表(FAT File Allocation Table) 
分配与内存分配相似 
  - 首次分配
  - 最佳适配</p>

<h2>  - 最近适配 (与前面分配文件块最近的组)</h2>

<ul>
<li>连续分配 一次性给一块连续的空间</li>
<li>连接分配 存一张表 分别为文件名 起始块 长度  每个文件块有一个向下一个文件块的指针</li>
<li>索引分配 存在一个表 记录每个块或者快的开始和长度</li>
</ul>

<h2>考试</h2>

<h4>进程调度</h4>

<ol>
<li>周转时间 </li>
<li>归一化周转时间   </li>
<li>响应时间 从进入等待队列开始  到用户得到反应  </li>
<li>吞吐量 </li>
<li>等待时间  </li>
<li>处理器利用率 单位时间内cpu时间所占比例</li>
</ol>

<h4>PV操作</h4>

<p>读者写者  生产者消费者</p>

<h4>银行家</h4>

<h4>页面置换</h4>

<ol>
<li>FIFO</li>
<li>OPT  每次换已有中最晚出现的</li>
<li>LRU</li>
<li>CLOCK  最开始几个指针不变</li>
<li><p>改进CLOCK</p>

<h2>6. BuffPage 工作集 </h2></li>
<li><p>操作系统功能</p></li>
<li>操作系统演变 </li>
<li>操作系统成就 虚拟机 多处理器设计 概念</li>
<li>Windows overview 大题</li>
<li>操作系统执行 概念</li>
<li>线程基本概念  为什么要有线程  线程 进程区别</li>
<li>互斥的硬件基础 不深</li>
<li>死锁概念 </li>
<li>银行家算法  和后面</li>
<li>需求 优缺点</li>
<li>虚存硬件软件机制 8.1 8.2</li>
<li>9.1 9.2</li>
<li>10.1 10.2  10.3 10.4 综合题</li>
<li>11.1-11.8</li>
<li>12.1 12.2 12.4 12.5  栈 堆</li>
</ol>
