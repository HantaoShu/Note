### Chapter 1 计算机系统漫游
#### 系统的硬件组成
1. 总线  
  总线负责在各个部件中信息传递 传递的单位是字 平时说的32位/64位就说的是字
2. I/O设备  
  IO设备通过控制器或适配器与IO总线相连 控制器和适配器就是我们平时说的某卡
3. 主存  
  主存由**动态随机存取存储器**(DRAM)芯片组成 这也和C语言类型大小有关
4. 处理器(CPU)  
  由PC控制 主要做加载 存储 操作 跳转等动作
5. 高速缓存用于解决处理器和主存间的速度差异 通常有三级的高速缓存 L1 L2 是通过**静态随机访问存储器**(SRAM)的技术完成的
![](http://o88xvi2w5.bkt.clouddn.com/CSAPP%E5%9B%BE1-4.png)
#### 存储层次图
![](http://o88xvi2w5.bkt.clouddn.com/CSAPP%20%E5%9B%BE1-18.png)
#### 操作系统的功能
1. 防止硬件被失控的应用程序滥用
2. 向应用程序提供简单一致的机制来控制复杂大相径庭的低级硬件设备

操作系统用了多个抽象的概念完成了这一目标

#### 进程与线程
进程是操作系统对各正在运行的程序的抽象,进程保存程序所需的上下文  
线程共享全部代码与数据 并且更容易在线程之间共享数据

#### 并行与并发
并发主要有三个层次 
1. 线程级并发
2. 指令级并行   -> 流水线
3. 单指令 多数据并行(SIMD并行)

#### 抽象
![](http://o88xvi2w5.bkt.clouddn.com/CSAPP%20%E5%9B%BE1-9.png)


## Chapter 2 程序结构和执行
#### 字节顺序
- 小端法 (little endian)  最低有效位在最前 Intel兼容机
- 大端法 (big endian)  最高哦有效为在最前 IBM 和 Sun 公司
- 双端法 (bi-endian) 可以配置成大端或者小端
- 截断  先转换为补码
- 有许多都要注意补码中负数比正数多一个 所以想取补码或者取-时都要注意
- 经典题 练习题 2.32 考虑MIN
#### 浮点数 IEEE标准
- 单精度 1 8 23
- 双精度 1 10 52
- 非规格化值 阶码为0 尾数为正常任意
- 无穷大 阶码全为1 尾数为0
- NAN 阶码为全为1 尾数非0
- 舍入 向偶数/0/上/下

## Chapter 4 处理器体系结构
### Y86指令
#### 组成 
1. 4个mov指令 irmovl rrmovl mrmovl rmmovl 分别代表立即数(i) 寄存器(r) 存储器(m)间的move 第一字母代表源 后面代表目的
2. 4个整数操作指令 addl subl andl xorl 会改变ZF SF OF (零 符号 溢出)
3. 7个跳转指令(jXX) jmp jle jl je jne jge jg
4. 6个条件传送指令 cmov(XX) XX同上 当条件满足时 更新目的寄存器值
5. call 返回地址入栈 跳到目标地址  ret 从过程调用返回
6. pushl popl 入栈 出栈
7. halt 停止执行

#### 编码
每条指令1-6字节不等 高四位代表代码 也就是之前的大类  第四位代表功能 是大类中的小类  
有两字节代表寄存器 7个寄存器对应编码  
4字节的常数字  
注意:常规是小端编码 需要倒过来写

#### 异常
对于Y86 有4中状态 
1 - AOK - 正常
2 - HLT - 执行halt指令
3 - ADR - 非法地址
4 - INS - 非法指令

### 流水线
目的: 提高吞吐量 副作用:增加了延迟  
做法: 增加了流水线寄存器
容易出现的问题: 
1. 不一致的划分导致延迟时间过大
2. 流水线过深导致收益下降

#### 分支预测
1. 预测下一个PC
2. 使用栈返回预测

#### 冒险


## Chapter 5 优化程序性能
编译器只使用安全的优化 主要不安全的优化有存储器别名使用 全局状态等  
1. 循环的低效率  比如for(int i=0;i<strlen();i++)  strlen每次都会运行
2. 减少调用过程 函数调用
-3. 消除不必要的存储器引用  临时变量代替指针引用

// 理解现代处理器

## Chapter 6 存储器层次结构
思想: 局部性思想
#### 存储技术
1. 静态RAM(SRAM)  用六晶体管电路实现  可以无限期的保持两个不同状态之一 即左稳态或右稳态
